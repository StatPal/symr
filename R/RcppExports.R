# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

mean_rice_R <- function(nu, sigma) {
    .Call('_symR_mean_rice_R', PACKAGE = 'symR', nu, sigma)
}

J <- function(n) {
    .Call('_symR_J', PACKAGE = 'symR', n)
}

eigenvals_J <- function(n) {
    .Call('_symR_eigenvals_J', PACKAGE = 'symR', n)
}

Bloch_eqn_R <- function(W_row, TE, TR) {
    .Call('_symR_Bloch_eqn_R', PACKAGE = 'symR', W_row, TE, TR)
}

v_mat_R <- function(W, TE, TR) {
    .Call('_symR_v_mat_R', PACKAGE = 'symR', W, TE, TR)
}

Generate_r <- function(W, TE, TR, sigma) {
    .Call('_symR_Generate_r', PACKAGE = 'symR', W, TE, TR, sigma)
}

dee_v_ij_dee_W_ik <- function(W_row, TE, TR, j, k) {
    .Call('_symR_dee_v_ij_dee_W_ik', PACKAGE = 'symR', W_row, TE, TR, j, k)
}

dee_2_v_ij_dee_W_ik_dee_W_ik1 <- function(W_row, TE, TR, j, k, k1) {
    .Call('_symR_dee_2_v_ij_dee_W_ik_dee_W_ik1', PACKAGE = 'symR', W_row, TE, TR, j, k, k1)
}

Init_val_least_sq_R <- function(train, TE_train, TR_train, our_dim_1, train_scale, TE_scale, TR_scale, maxiter_LS, W_1_init, W_2_init) {
    .Call('_symR_Init_val_least_sq_R', PACKAGE = 'symR', train, TE_train, TR_train, our_dim_1, train_scale, TE_scale, TR_scale, maxiter_LS, W_1_init, W_2_init)
}

AECM_R <- function(W, our_dim_1, TE_train, TR_train, sigma_train, train, train_scale, TE_scale, TR_scale, black_list, maxiter = 50L, penalized = 1L, abs_diff = 1e-1, rel_diff = 1e-5, verbose = 0L, verbose2 = 0L) {
    .Call('_symR_AECM_R', PACKAGE = 'symR', W, our_dim_1, TE_train, TR_train, sigma_train, train, train_scale, TE_scale, TR_scale, black_list, maxiter, penalized, abs_diff, rel_diff, verbose, verbose2)
}

OSL_R <- function(W, our_dim_1, TE_train, TR_train, sigma_train, train, train_scale, TE_scale, TR_scale, black_list, maxiter = 50L, penalized = 1L, abs_diff = 1e-1, rel_diff = 1e-5, verbose = 0L, verbose2 = 0L) {
    .Call('_symR_OSL_R', PACKAGE = 'symR', W, our_dim_1, TE_train, TR_train, sigma_train, train, train_scale, TE_scale, TR_scale, black_list, maxiter, penalized, abs_diff, rel_diff, verbose, verbose2)
}

Performance_test_R <- function(W, test, TE_test, TR_test, sigma_test, black_list, v_type = 1L, measure_type = 1L, scale = 1L, verbose = 0L) {
    .Call('_symR_Performance_test_R', PACKAGE = 'symR', W, test, TE_test, TR_test, sigma_test, black_list, v_type, measure_type, scale, verbose)
}

AECM_R_3D <- function(W, our_dim_1, TE_train, TR_train, sigma_train, train, train_scale, TE_scale, TR_scale, black_list, maxiter = 50L, penalized = 1L, abs_diff = 1e-1, rel_diff = 1e-5, verbose = 0L, verbose2 = 0L) {
    .Call('_symR_AECM_R_3D', PACKAGE = 'symR', W, our_dim_1, TE_train, TR_train, sigma_train, train, train_scale, TE_scale, TR_scale, black_list, maxiter, penalized, abs_diff, rel_diff, verbose, verbose2)
}

OSL_R_3D <- function(W, our_dim_1, TE_train, TR_train, sigma_train, train, train_scale, TE_scale, TR_scale, black_list, maxiter = 50L, penalized = 1L, abs_diff = 1e-1, rel_diff = 1e-5, verbose = 0L, verbose2 = 0L) {
    .Call('_symR_OSL_R_3D', PACKAGE = 'symR', W, our_dim_1, TE_train, TR_train, sigma_train, train, train_scale, TE_scale, TR_scale, black_list, maxiter, penalized, abs_diff, rel_diff, verbose, verbose2)
}




symR <- function(W=NULL, 
    method=c("LS", "Least Square", "ML", "Maximum Likelihood", "OSL-EM", "One Step Late EM", "AECM", "EM"), 
    our_dim_1, TE_train, TR_train, sigma_train, train, train_scale, TE_scale, TR_scale, black_list, maxiter = 50L, penalized = 1L, abs_diff = 1e-1, rel_diff = 1e-5, verbose = 0L, verbose2 = 0L) 
{
    if(method=="LS" | method== "Least Square"){
        .Call('_symR_Init_val_least_sq_R', PACKAGE = 'symR', train, TE_train, TR_train, our_dim_1, train_scale, TE_scale, TR_scale, maxiter_LS, W_1_init, W_2_init)
    } else {
        ##  If W is not given for other methods, take the initial simplest guess.
        if(is.null(W)){
            n = NROW(train)
            W <- array(1, dim=c(n, 3))
            W[,1] <- colMeans(train)
            W[,2] <- array(W_1_init, dim=n)
            W[,3] <- array(W_2_init, dim=n)
            ## Numerical modifications:
            W[,1] <- ifelse(W[,1]>450.0, 425.0, W[,1])
            W[,1] <- ifelse(W[,1]<0.0001, 0.0001, W[,1])
        }
        ## So there is an estimated W now.

        ## Check 2D/3D:
        if(our_dim_1[4]==1){
            ## 2D - OSL/MLE/AECM:
            if(method == "ML" | method == "Maximum Likelihood"){
                .Call('_symR_OSL_R_2D', PACKAGE = 'symR', W, our_dim_1, TE_train, TR_train, sigma_train, train, train_scale, TE_scale, TR_scale, black_list, maxiter, 0L, abs_diff, rel_diff, verbose, verbose2)
                ## Or the AECM???? (Two step case - but more checked - Subrata)
            } else if(method == "OSL-EM" | method == "One Step Late EM"){
                .Call('_symR_OSL_R_2D', PACKAGE = 'symR', W, our_dim_1, TE_train, TR_train, sigma_train, train, train_scale, TE_scale, TR_scale, black_list, maxiter, 1L, abs_diff, rel_diff, verbose, verbose2)
            } else if(method == "EM" | method == "AECM"){
                .Call('_symR_AECM_R_2D', PACKAGE = 'symR', W, our_dim_1, TE_train, TR_train, sigma_train, train, train_scale, TE_scale, TR_scale, black_list, maxiter, 1L, abs_diff, rel_diff, verbose, verbose2)
            }
        } else if(our_dim_1[4]>1){
            ## 3D - OSL/MLE/AECM:
            if(method == "ML" | method == "Maximum Likelihood"){
                .Call('_symR_OSL_R_3D', PACKAGE = 'symR', W, our_dim_1, TE_train, TR_train, sigma_train, train, train_scale, TE_scale, TR_scale, black_list, maxiter, 0L, abs_diff, rel_diff, verbose, verbose2)
                ## Or the AECM???? (Two step case - but more checked - Subrata)
            } else if(method == "OSL-EM" | method == "One Step Late EM"){
                .Call('_symR_OSL_R_3D', PACKAGE = 'symR', W, our_dim_1, TE_train, TR_train, sigma_train, train, train_scale, TE_scale, TR_scale, black_list, maxiter, 1L, abs_diff, rel_diff, verbose, verbose2)
            } else if(method == "EM" | method == "AECM"){
                .Call('_symR_AECM_R_3D', PACKAGE = 'symR', W, our_dim_1, TE_train, TR_train, sigma_train, train, train_scale, TE_scale, TR_scale, black_list, maxiter, 1L, abs_diff, rel_diff, verbose, verbose2)
            }
        }
    }
}
